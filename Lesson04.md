# Lesson 4

## Title 1 - Introduction
Here at Atlanta we are homes the world's busiest airport. They have five runways and 2,500 arrivals and departures per day. &gt;&gt; Have you ever wondered how they schedule all those flights? Those runways are putting out a plane every 30 seconds. &gt;&gt; Wow, it turns out this is an example of a classic AI problem called constraint satisfaction. Let's start out with a simple example as a challenge question.

## Title 2 - Map Coloring
Map coloring is another classic example of constraint satisfaction. &gt;&gt; We are trying to color this map of Australia, using the minimum number of colors as possible. But making sure that no neighboring regions have the same color. &gt;&gt; I guess if they had the same color, it would be hard to tell where one territory stopped and the next began. &gt;&gt; Exactly, we can set up the problem more formally by first listing all the variables, in this case the territories. &gt;&gt; And the possible colors of the territories are listed as the domains of the problem. &gt;&gt; Finally, the rules of the problem, that no territory can be assigned the same color as a neighboring territory, are listed as the constraints. &gt;&gt; We can do that explicitly by listing all the possible pairwise constraints. Like how Western Australia's color can't be be the same as the Northern Territory. Or we could list all the allowable assignments for each pair of territories. &gt;&gt; A solution is an assignment of colors to each of the territories that satisfies all the constraints. &gt;&gt; I always wanted to paint Australia red.

## Title 3 - Constraint Graph
Anyway, unary constraints restrict the value of a given variable, like saying Tasmania can't be purple. &gt;&gt; Binary constraints relate, at most, two variables. We can represent those with a constraint graph. &gt;&gt; Here's a constraint graph for our Australia coloring problem. Nodes are the variables, like Western Australia, South Australia, Queensland, etc. Arcs show the constraints between the variables. &gt;&gt; We can apply general-purpose constraint satisfaction problem algorithms to the graph structure to speed up our search for an answer. For example, Tasmania is independent from the rest of the problem.

## Title 4 - Map Coloring Quiz
Now try this map coloring problem. Color each region by typing in a number to represent your color. For example type the number one to represent color number one, two for color number two, and so on. What is the minimum number of colors needed for this map?

## Title 5 - Map Coloring Quiz Solution
Here is one possible set of answers. Answers could vary depending on where you started coloring in the map. We had four colors, at minimum, to color in this map because of all the adjacent regions in the center.

## Title 6 - CSP Examples
Besides unary and binary constraints, we could have constraints that involve 3 or more variables or soft constraints like the fact that I prefer to teach on a Tuesday/Thursday schedule. Problems with preference constraints are called constraint optimization problems and are with solving linear programming. &gt;&gt; There are lots of examples of constraint satisfaction problems. Sudoku is a classic game which can be solved with any of the methods we will be teaching. &gt;&gt; Other examples include car assembly, job scheduling in factories, class scheduling, spreadsheets, transportation scheduling or floor planning. Many of these require real-valued variables.

## Title 7 - Constraint Hypergraph
Let's look at an example of cryptarithmetic, the classic two + two = four problem. Here, we have unary constraints, which we'll represent by square boxes on a constraint hypergraph. For example, there is a global constraint, that none of the letters can represent the same digit. &gt;&gt; And another is, that O+O has to equal R except in the case that there is a carry to the next column, which we'll represent as a new variable, x1, which could be 0 or 1. We can write that as the constraint, O+O=R+10x1 and show it on our constrain hypergraph, like this. We'll revisit this problem again later.

## Title 8 - Backtracking Search  1
So which algorithm are we going to show first to solve constraint satisfaction problems? &gt;&gt; Well the stupid one first of course. &gt;&gt; I had to ask. &gt;&gt; Then we'll add intelligence as we need it. &gt;&gt; Okay, we'll use simple search. States are defined by the values assigned so far. &gt;&gt; The initial state is the empty assignment. First we'll check to see if the current assignment is the goal. &gt;&gt; Then we will assign a value to unassigned variable that does not conflict with the current assignment. &gt;&gt; We call it a dead end if there are no legal assignments. In that case, we will back up to the previous date and try another assignment. &gt;&gt; And we will recurse until you either find the answer or try all the possible assignments and report failure. &gt;&gt; Let's make the algorithm concrete by doing an example. &gt;&gt; Okay, here's our map of Australia. &gt;&gt; We will work with Western Australia first. You can have one of three colors, orange, green, or blue. &gt;&gt; I'll choose orange. &gt;&gt; Okay, what section do you want us to look at next? &gt;&gt; How about the Northern Territory. &gt;&gt; Great, since we chose orange for Western Australia, the Northern Territory can have two colors, green or blue. &gt;&gt; Let's choose green. &gt;&gt; Okay, now let's work with Queensland next. It can be orange or blue. &gt;&gt; Let's choose blue. &gt;&gt; But now we are in trouble, there are no colors left for South Australia. &gt;&gt; Okay well, that's a dead end. Let's back up and try the other branch where we only used orange and green up to this point. &gt;&gt; And eventually we'll find the answer this way, but we can improve the efficiency of the algorithm significantly.

## Title 9 - Improving Backtracking Efficiency
I guess we've already seen one optimization. &gt;&gt; How so? &gt;&gt; If I choose the least concerning value for Queensland, we would not have had to backup. Let me show you. We started with Western Australia being orange, then the Northern Territory was green. Since Queensland is not next to Western Australia, I can use orange again. That will leave blue unused. So orange was the value that least constrained our future choices. &gt;&gt; Now you get it. &gt;&gt; Another optimization is to choose to assign the variable with the minimum remaining values next. &gt;&gt; If we start with assigning Western Australia and then the Northern Territory colors, the variable with the least number of values remaining is South Australia, so we should choose one that next to assign. &gt;&gt; What if I have a tie? &gt;&gt; What do you mean? &gt;&gt; In this example, we have assigned Southern Australia and Northern Territory. There are two regions that can only be assigned orange, Queensland and Western Australia. Which do we choose? &gt;&gt; Choose the one with the most constraints. &gt;&gt; You mean Queensland in this case because it borders New South Wales as well as the Northern Territory and Southern Australia. Western Australia only borders Northern Territory and Southern Australia, so it's not as complex. By choosing the one that's more constrained in the future, we'll be able to run into problems sooner rather than delaying them. &gt;&gt; Correct. &gt;&gt; Okay, how much do these improvements to backtracking help? &gt;&gt; Remember our End Queens problem? &gt;&gt; Yeah. &gt;&gt; It is another example of a constraint satisfaction problem. &gt;&gt; Okay. &gt;&gt; Using the least constraining value and minimum remaining values heuristics to improve backtracking search will allow us to do the 1,000 Queens problem. &gt;&gt; I don't expect I could ever do that by hand. That's impressive. &gt;&gt; You haven't seen anything yet. 

## Title 10 - Backtracking Optimization Quiz
Let's consider the optimizations we just discussed. For this half colored map, which region should we fill in next in order to minimize backtracking? There might be multiple answers here. But choose one of these optimizations and choose the region that matches with that.

## Title 11 - Backtracking Optimization Quiz Solution
Here are two possible answers. This region is holding a green region and an orange region, so it only has two options for colors. Compared to all other regions, this is the minimum remaining values of those regions. For this region, we can pick the least constraining value which is green in this case. Because its bordering region can only take light blue or dark blue. So avoiding those two choices gives us more options later on.

## Title 12 - Forward Checking
Our next optimization is forward checking. Basically, for each unassigned variable, we're going to keep track of the remaining legal values. &gt;&gt; I get it. So if ever make a decision that causes an unassigned variable to not be able to have a value, we stop our search and backup. &gt;&gt; Right. &gt;&gt; Let's try that with the Australia example. We start with nothing colored and all the regions could have any of the three colors. &gt;&gt; In our first step, we assign orange to Western Australia. That removes orange from the colors available to the Northern Territory and to Southern Australia. &gt;&gt; Suppose we assign green to Queensland. Now both the Northern Territory and Southern Australia can only have blue, and New South Wales can have orange or blue. If we assign blue to Victoria. &gt;&gt; Then we see that New South Wales can only have orange. The Northern Territory can only have blue and South Australia can't have anything. &gt;&gt; So we figured out that we are stuck and can backtrack earlier than we would have if we tried to continue assigning variables. &gt;&gt; Exactly, forward checking is an early warning system that a surge is going down the wrong branch.

## Title 13 - Constraint Propagation and Arc Consistency
However, I noticed we could've stop our search earlier. &gt;&gt; How? &gt;&gt; At this step we said the Northern Territory in South Australia both had to be blue. &gt;&gt; So? &gt;&gt; But this two regions are adjacent. We know they can't both be blue. &gt;&gt; I see, for checking propagates information from assigned to unassigned variables but doesn't provide early detection from all failures. Instead, we can use constraint propagation repeatedly to enforce all the local constraints. &gt;&gt; We can use Arc Consistency for a simple version of constraint propagation. A variable, and a constraint satisfaction problem is arc consistent, with respect to another variable, if there is some value still available for the second variable, after we assign a value to the first variable. If all variables in a graph satisfies this condition, then the network is arc consistent. &gt;&gt; Let's look at the practical example. Once we get to the stage of signing green to Queensland we look at of its neighbors that are unassigned and see if the assignment of green reduces the number colors available to them. If so, we remove from a neighboring region. And then look at its neighboring regions to see if we need to appropriate the change onward. We keep doing this process until it terminates or we determine that one of the regions does not have any colors left. &gt;&gt; So here, we have removed green from South Australia's list and we're now looking at its neighbors. New South Wales is a neighbor, and in order to be arc consistent, we will have to remove blue from its available colors. It can only be orange. &gt;&gt; Victoria is a neighbor of New South Wales so we look to see if the change affects it. In fact it does. We remove orange from Victoria's list of available colors. Our choice in green for Queensland has caused a chain of changes in possible values for our variables. &gt;&gt; Why don't we remove blue, while we're at it so Victoria doesn't conflict with South Australia? &gt;&gt; Well, we haven't gotten that far in our queue of things to check yet. Next, we're going to look at the Northern Territory because it has another neighbor that might be affected by South Australia's change. In fact, we see South Australia and the Northern Territory are both restricted to blue which is not allowed. So we return a failure and force the search to try another option for Queensland. &gt;&gt; Wow, that was a lot of work. &gt;&gt; But it can save a lot of unnecessary deep searching for more complicated problems.

## Title 14 - Constraint Propagation Quiz
Here's a map where we've colored in two regions for you. Given this state in the map coloring, propagate through the constraints to make each variable arc consistent. Check the boxes to indicate which color is possible in each region. Finally, is the entire network arc consistent?

## Title 15 - Constraint Propagation Quiz Solution  1
Here's the answer. We have several islands on this map, so they can have any of the three colors. However, K2 is constrained to only one color, green, because of the two bordering regions. Finally, the entire network is arc consistent, because we don't have any regions without a possible color. [BLANK_AUDIO]

## Title 16 - Structured CSPs
Speaking about saving time through deep searching another powerful trick is to look at the structure of the problem and see if we can decompose it to several independent problems. &gt;&gt; For example, Tasmania is independent of the rest of the Australia problem. We can solve it separately. &gt;&gt; Which takes a level off our search tree. In general, suppose we have a problem with 80 binary variables. We can divide it into 4 problems of 20 variables. We go from a search space of 2 to the 80th to 4 times 2 to the 20th. &gt;&gt; Even better, if we have a CSP where there are no loops, we can solve the problem in OND squared time instead of OD to the N. &gt;&gt; How? &gt;&gt; We pick any variable to be the root of the tree and choose an ordering of the variable such that each variable appeared after its parent in the tree. We then start at the end and make each parent arc consistent, going up the tree until we get to the top. &gt;&gt; What if that is not possible? &gt;&gt; Then we report failure of the problem. &gt;&gt; Okay. What's next? &gt;&gt; It's simple. We start at the top of the tree and pick any assignment available. Going back down the tree until we get to the end. Since the trees aren't consistent any of the available assignments will solve the problem. &gt;&gt; How fast is this process? O of ND squared where N is the number of variables again and D is the size of the domain. &gt;&gt; So this trick really helps out with the speed of finding a solution. But what if the constrain graph really isn't a tree? &gt;&gt; Well, sometimes you condition a problem by assigning value to some variables and change the constrain graph into a tree. &gt;&gt; Like with our Australia coloring example. If we assign a value to South Australia first and remove that value from the possibilities of its neighbors, then the problem becomes a tree and we can use our fast method to solve the problem. &gt;&gt; Precisely.

## Title 17 - Iterative Algorithms
Hold on, we said that N queen was a constraints satisfaction problem. When we cover that in the last lesson using generic algorithms or hill climbing algorithms to solve the problem. &gt;&gt; That's right, we can randomly assign values to the variable and iteratively improve the assignments until we come to the solution. &gt;&gt; Like our previous example with four queens, while there were four to the four, which equals 256 possible states, we can quickly find the solution by minimizing the number of attacks with each improvement. &gt;&gt; In fact, this minimizing conflict method can solve N queens with N equals 10 million. In the million queens case, this min conflicts algorithm can solve the problem in an average of 50 moves. Wow, I guess that's because there's a large number of solutions to the problem. &gt;&gt; Yep, iterative improvement algorithms work well when there are many solutions and when there are very few. However, there are problems with the number constraints versus the number of variables hit a certain ratio. And the problem becomes very hard to solve. &gt;&gt; Well, then let's stick to the easy ones.

## Title 18 - Challenge Question Revisited  1
Now that we've been learning a few tricks, let's reexamine the challenge question. We'll use our constraint hypergraph for the problem where the top square represents the global constraint that all the letters have to be different. In addition, we know that O + O has to be equal to R + 10 times X1, where X1 represents the carry to the tens place and it can be 0 or 1. Similarly, x1 + W + W has to equal U + 10 times x2, where x2 represents the carry to the hundredth place. Also, x2 + T + T has got to equal 0 + 10 times x3, where x3 is the carry to the thousandth place. And F has to equal X3. We also know that F can not be 0, because the problem does not allow leading 0's. So now we're going to use the strategy we learned of back tracking with forward checking and the MRV and least constraining value heuristics. There are a couple of ways to follow this procedure. And we'll show one here for illustration purposes. First, let's choose the X3 variable. If the main is 0 and 1, choose the value 1 for X3. We can't choose 0, it wouldn't survive forward checking. Because it would cause F to be 0. The leading digit of the sum must be non 0. Choose F, because it has only one remaining value. Choose the value 1 for F. Now X2 and X1 are tied for minimum remaining values at 2. Let's choose X2, either values survives forward checking. Let's choose 0 for X2. Now X1 has the minimum remaining values. Again, arbitrary choose 0 for the value for X1. The variable O must be an even number, because it is the sum of T + T less than 5. Because O + O = R +10 times 0. That makes it most constrained. Arbitrarily choose 4 as the value for O. Now R has only one remaining value. Choose the value 8 for R. T now has only one remaining value. Choose a value, 7, for T. U must be an even number less than 9. Choose U, the only value for U that survives forward checking is 6. The only variable left is W. The only value left for W is 3. This is the solution. This puzzle is rather easy because it is under-constrained. It is not surprising that we arrive at a solution with no backtracking given that we are allowed to use forward checking. We could have used iterative improvement for this problem and probably would have converged quickly as it's under-constrained. But I find it difficult to keep all those numbers and letters in my head.
